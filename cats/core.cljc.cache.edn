;; Analyzed by ClojureScript 1.8.40
{:use-macros {mlet cats.core}, :excludes #{when unless filter sequence}, :name cats.core, :imports nil, :requires {p cats.protocols, cats.protocols cats.protocols, clojure.set clojure.set, ctx cats.context, cats.context cats.context}, :uses nil, :defs {arity {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 486, :column 8, :end-line 486, :end-column 13, :private true, :arglists (quote ([var]))}, :private true, :name cats.core/arity, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 13, :method-params ([var]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 486, :end-line 486, :max-fixed-arity 1, :fn-var true, :arglists (quote ([var]))}, pure {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 54, :column 7, :end-line 54, :end-column 11, :arglists (quote ([v] [ctx v])), :doc "Given any value `v`, return it wrapped in\n  the default/effect-free context.\n\n  This is a multi-arity function that with arity `pure/1`\n  uses the dynamic scope to resolve the current\n  context. With `pure/2`, you can force a specific context\n  value.\n\n  Example:\n\n      (with-context either/context\n        (pure 1))\n      ;; => #<Right [1]>\n\n      (pure either/context 1)\n      ;; => #<Right [1]>\n  ", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([v] [ctx v]), :arglists ([v] [ctx v]), :arglists-meta (nil nil)}}, :name cats.core/pure, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([v] [ctx v]), :arglists ([v] [ctx v]), :arglists-meta (nil nil)}, :method-params ([v] [ctx v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 54, :end-line 54, :max-fixed-arity 2, :fn-var true, :arglists ([v] [ctx v]), :doc "Given any value `v`, return it wrapped in\n  the default/effect-free context.\n\n  This is a multi-arity function that with arity `pure/1`\n  uses the dynamic scope to resolve the current\n  context. With `pure/2`, you can force a specific context\n  value.\n\n  Example:\n\n      (with-context either/context\n        (pure 1))\n      ;; => #<Right [1]>\n\n      (pure either/context 1)\n      ;; => #<Right [1]>\n  "}, arglists {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 476, :column 8, :end-line 476, :end-column 16, :private true, :arglists (quote ([var]))}, :private true, :name cats.core/arglists, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 16, :method-params ([var]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 476, :end-line 476, :max-fixed-arity 1, :fn-var true, :arglists (quote ([var]))}, foldl {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 796, :column 7, :end-line 796, :end-column 12, :arglists (quote ([f z xs])), :doc "Perform a left-associative fold on the data structure."}, :name cats.core/foldl, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 12, :method-params ([f z xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 796, :end-line 796, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f z xs])), :doc "Perform a left-associative fold on the data structure."}, fapply {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 186, :column 7, :end-line 186, :end-column 13, :arglists (quote ([af & avs])), :doc "Given a function wrapped in a monadic context `af`,\n  and a value wrapped in a monadic context `av`,\n  apply the unwrapped function to the unwrapped value\n  and return the result, wrapped in the same context as `av`.\n\n  This function is variadic, so it can be used like\n  a Haskell-style left-associative fapply.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(af avs)], :arglists ([af & avs]), :arglists-meta (nil)}}, :name cats.core/fapply, :variadic true, :file "out.prod.client/cats/core.cljc", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(af avs)], :arglists ([af & avs]), :arglists-meta (nil)}, :method-params [(af avs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 186, :end-line 186, :max-fixed-arity 1, :fn-var true, :arglists ([af & avs]), :doc "Given a function wrapped in a monadic context `af`,\n  and a value wrapped in a monadic context `av`,\n  apply the unwrapped function to the unwrapped value\n  and return the result, wrapped in the same context as `av`.\n\n  This function is variadic, so it can be used like\n  a Haskell-style left-associative fapply."}, <*> {:name cats.core/<*>, :file "out.prod.client/cats/core.cljc", :line 733, :column 1, :end-line 733, :end-column 9, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 733, :column 6, :end-line 733, :end-column 9}, :doc "A Haskell-style `fapply` alias."}, guard {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 110, :column 7, :end-line 110, :end-column 12, :arglists (quote ([b]))}, :name cats.core/guard, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 12, :method-params ([b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 110, :end-line 110, :max-fixed-arity 1, :fn-var true, :arglists (quote ([b]))}, join {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 116, :column 7, :end-line 116, :end-column 11, :arglists (quote ([mv])), :doc "Remove one level of monadic structure.\n  This is the same as `(bind mv identity)`."}, :name cats.core/join, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 11, :method-params ([mv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 116, :end-line 116, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mv])), :doc "Remove one level of monadic structure.\n  This is the same as `(bind mv identity)`."}, bimap {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 133, :column 7, :end-line 133, :end-column 12, :arglists (quote ([f g] [f g bv])), :doc "Map over both arguments at the same time.\n\n  Given functions `f` and `g` and a value wrapped in a bifunctor `bv`,\n  apply `f` to a first argument or `g` to a second argument.\n\n      (bimap dec inc (either/right 1)\n      ;; => #<Right 2>\n\n      (bimap dec inc (either/left 1)\n      ;; => #<Left 0>", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f g] [f g bv]), :arglists ([f g] [f g bv]), :arglists-meta (nil nil)}}, :name cats.core/bimap, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f g] [f g bv]), :arglists ([f g] [f g bv]), :arglists-meta (nil nil)}, :method-params ([f g] [f g bv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 133, :end-line 133, :max-fixed-arity 3, :fn-var true, :arglists ([f g] [f g bv]), :doc "Map over both arguments at the same time.\n\n  Given functions `f` and `g` and a value wrapped in a bifunctor `bv`,\n  apply `f` to a first argument or `g` to a second argument.\n\n      (bimap dec inc (either/right 1)\n      ;; => #<Right 2>\n\n      (bimap dec inc (either/left 1)\n      ;; => #<Left 0>"}, bind {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 81, :column 7, :end-line 81, :end-column 11, :arglists (quote ([mv f])), :doc "Given a monadic value `mv` and a function `f`,\n  apply `f` to the unwrapped value of `mv`.\n\n      (bind (either/right 1) (fn [v]\n                               (return (inc v))))\n      ;; => #<Right [2]>\n\n  For convenience, you may prefer to use the `mlet` macro,\n  which provides a beautiful, `let`-like syntax for\n  composing operations with the `bind` function."}, :name cats.core/bind, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 11, :method-params ([mv f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 81, :end-line 81, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mv f])), :doc "Given a monadic value `mv` and a function `f`,\n  apply `f` to the unwrapped value of `mv`.\n\n      (bind (either/right 1) (fn [v]\n                               (return (inc v))))\n      ;; => #<Right [2]>\n\n  For convenience, you may prefer to use the `mlet` macro,\n  which provides a beautiful, `let`-like syntax for\n  composing operations with the `bind` function."}, deps {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 271, :column 8, :end-line 271, :end-column 12, :private true, :arglists (quote ([expr syms]))}, :private true, :name cats.core/deps, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 12, :method-params ([expr syms]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 271, :end-line 271, :max-fixed-arity 2, :fn-var true, :arglists (quote ([expr syms]))}, topo-sort* {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 353, :column 8, :end-line 353, :end-column 18, :private true, :arglists (quote ([deps seen batches current]))}, :private true, :name cats.core/topo-sort*, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 18, :method-params ([deps seen batches current]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 353, :end-line 353, :max-fixed-arity 4, :fn-var true, :arglists (quote ([deps seen batches current]))}, <$> {:name cats.core/<$>, :file "out.prod.client/cats/core.cljc", :line 729, :column 1, :end-line 729, :end-column 9, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 729, :column 6, :end-line 729, :end-column 9}, :doc "A Haskell-style `fmap` alias."}, <=< {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 772, :column 7, :end-line 772, :end-column 10, :arglists (quote ([mg mf x])), :doc "Right-to-left composition of monads.\n  Same as `>=>` with its first two arguments flipped."}, :name cats.core/<=<, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 10, :method-params ([mg mf x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 772, :end-line 772, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mg mf x])), :doc "Right-to-left composition of monads.\n  Same as `>=>` with its first two arguments flipped."}, alet* {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 383, :column 8, :end-line 383, :end-column 13, :private true, :arglists (quote ([batches env body]))}, :private true, :name cats.core/alet*, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 13, :method-params ([batches env body]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 383, :end-line 383, :max-fixed-arity 3, :fn-var true, :arglists (quote ([batches env body]))}, lift {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 219, :column 7, :end-line 219, :end-column 11, :arglists (quote ([mv] [m mv])), :doc "Lift a value from the inner monad of a monad transformer\n  into a value of the monad transformer.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([mv] [m mv]), :arglists ([mv] [m mv]), :arglists-meta (nil nil)}}, :name cats.core/lift, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([mv] [m mv]), :arglists ([mv] [m mv]), :arglists-meta (nil nil)}, :method-params ([mv] [m mv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 219, :end-line 219, :max-fixed-arity 2, :fn-var true, :arglists ([mv] [m mv]), :doc "Lift a value from the inner monad of a monad transformer\n  into a value of the monad transformer."}, single-arity? {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 480, :column 8, :end-line 480, :end-column 21, :private true, :arglists (quote ([var]))}, :private true, :name cats.core/single-arity?, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 21, :method-params ([var]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 480, :end-line 480, :max-fixed-arity 1, :fn-var true, :arglists (quote ([var]))}, when {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 199, :column 7, :end-line 199, :end-column 11, :arglists (quote ([b mv] [ctx b mv])), :doc "Given an expression and a monadic value,\n  if the expression is logical true, return the monadic value.\n  Otherwise, return nil in a monadic context.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([b mv] [ctx b mv]), :arglists ([b mv] [ctx b mv]), :arglists-meta (nil nil)}}, :name cats.core/when, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([b mv] [ctx b mv]), :arglists ([b mv] [ctx b mv]), :arglists-meta (nil nil)}, :method-params ([b mv] [ctx b mv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 199, :end-line 199, :max-fixed-arity 3, :fn-var true, :arglists ([b mv] [ctx b mv]), :doc "Given an expression and a monadic value,\n  if the expression is logical true, return the monadic value.\n  Otherwise, return nil in a monadic context."}, >>= {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 737, :column 7, :end-line 737, :end-column 10, :arglists (quote ([mv f] [mv f & fs])), :doc "Perform a Haskell-style left-associative bind.\n\n  Let's see it in action:\n\n      (>>= (just 1) (comp just inc) (comp just inc))\n      ;; => #<Just [3]>\n  ", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([mv f]), :arglists ([mv f] [mv f & fs]), :arglists-meta (nil nil)}}, :name cats.core/>>=, :variadic true, :file "out.prod.client/cats/core.cljc", :end-column 10, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([mv f]), :arglists ([mv f] [mv f & fs]), :arglists-meta (nil nil)}, :method-params ([mv f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 737, :end-line 737, :max-fixed-arity 2, :fn-var true, :arglists ([mv f] [mv f & fs]), :doc "Perform a Haskell-style left-associative bind.\n\n  Let's see it in action:\n\n      (>>= (just 1) (comp just inc) (comp just inc))\n      ;; => #<Just [3]>\n  "}, mzero {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 98, :column 7, :end-line 98, :end-column 12, :arglists (quote ([] [ctx])), :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [ctx]), :arglists ([] [ctx]), :arglists-meta (nil nil)}}, :name cats.core/mzero, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [ctx]), :arglists ([] [ctx]), :arglists-meta (nil nil)}, :method-params ([] [ctx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 98, :end-line 98, :max-fixed-arity 1, :fn-var true, :arglists ([] [ctx])}, return {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 75, :column 7, :end-line 75, :end-column 13, :arglists (quote ([v] [ctx v])), :doc "This is a monad version of `pure` and works\n  identically to it.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([v] [ctx v]), :arglists ([v] [ctx v]), :arglists-meta (nil nil)}}, :name cats.core/return, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([v] [ctx v]), :arglists ([v] [ctx v]), :arglists-meta (nil nil)}, :method-params ([v] [ctx v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 75, :end-line 75, :max-fixed-arity 2, :fn-var true, :arglists ([v] [ctx v]), :doc "This is a monad version of `pure` and works\n  identically to it."}, mappend {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 48, :column 7, :end-line 48, :end-column 14, :arglists (quote ([& svs])), :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(svs)], :arglists ([& svs]), :arglists-meta (nil)}}, :name cats.core/mappend, :variadic true, :file "out.prod.client/cats/core.cljc", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(svs)], :arglists ([& svs]), :arglists-meta (nil)}, :method-params [(svs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 48, :end-line 48, :max-fixed-arity 0, :fn-var true, :arglists ([& svs])}, mapseq {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 659, :column 7, :end-line 659, :end-column 13, :arglists (quote ([mf coll])), :doc "Given a function `mf` that takes a value and puts it into a\n  monadic context, and a collection, map `mf` over the collection,\n  calling `sequence` on the results.\n\n      (require '[cats.context :as ctx]\n               '[cats.monad.maybe :as maybe]\n               '[cats.core :as m])\n\n      (m/mapseq maybe/just [2 3])\n      ;=> <Just [[2 3]]>\n\n      (m/mapseq (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing)))\n                [1 2])\n      ;; => #<Nothing>\n\n      (ctx/with-context maybe/context\n        (mapseq #(maybe/just (* % 2)) []))\n      ;; => #<Just [()]>\n  "}, :name cats.core/mapseq, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 13, :method-params ([mf coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 659, :end-line 659, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf coll])), :doc "Given a function `mf` that takes a value and puts it into a\n  monadic context, and a collection, map `mf` over the collection,\n  calling `sequence` on the results.\n\n      (require '[cats.context :as ctx]\n               '[cats.monad.maybe :as maybe]\n               '[cats.core :as m])\n\n      (m/mapseq maybe/just [2 3])\n      ;=> <Just [[2 3]]>\n\n      (m/mapseq (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing)))\n                [1 2])\n      ;; => #<Nothing>\n\n      (ctx/with-context maybe/context\n        (mapseq #(maybe/just (* % 2)) []))\n      ;; => #<Just [()]>\n  "}, mplus {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 104, :column 7, :end-line 104, :end-column 12, :arglists (quote ([& mvs])), :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(mvs)], :arglists ([& mvs]), :arglists-meta (nil)}}, :name cats.core/mplus, :variadic true, :file "out.prod.client/cats/core.cljc", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(mvs)], :arglists ([& mvs]), :arglists-meta (nil)}, :method-params [(mvs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 104, :end-line 104, :max-fixed-arity 0, :fn-var true, :arglists ([& mvs])}, dedupe-symbols {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 331, :column 8, :end-line 331, :end-column 22, :private true, :arglists (quote ([bindings body]))}, :private true, :name cats.core/dedupe-symbols, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 22, :method-params ([bindings body]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 331, :end-line 331, :max-fixed-arity 2, :fn-var true, :arglists (quote ([bindings body]))}, >> {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 750, :column 7, :end-line 750, :end-column 9, :arglists (quote ([mv mv'] [mv mv' & mvs])), :doc "Perform a Haskell-style left-associative bind,\n  ignoring the values produced by the monadic computations.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([mv mv']), :arglists ([mv mv'] [mv mv' & mvs]), :arglists-meta (nil nil)}}, :name cats.core/>>, :variadic true, :file "out.prod.client/cats/core.cljc", :end-column 9, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([mv mv']), :arglists ([mv mv'] [mv mv' & mvs]), :arglists-meta (nil nil)}, :method-params ([mv mv']), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 750, :end-line 750, :max-fixed-arity 2, :fn-var true, :arglists ([mv mv'] [mv mv' & mvs]), :doc "Perform a Haskell-style left-associative bind,\n  ignoring the values produced by the monadic computations."}, rename {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 288, :column 8, :end-line 288, :end-column 14, :private true, :arglists (quote ([expr renames]))}, :private true, :name cats.core/rename, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 14, :method-params ([expr renames]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 288, :end-line 288, :max-fixed-arity 2, :fn-var true, :arglists (quote ([expr renames]))}, rename-sym {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 284, :column 8, :end-line 284, :end-column 18, :private true, :arglists (quote ([expr renames]))}, :private true, :name cats.core/rename-sym, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 18, :method-params ([expr renames]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 284, :end-line 284, :max-fixed-arity 2, :fn-var true, :arglists (quote ([expr renames]))}, unless {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 210, :column 7, :end-line 210, :end-column 13, :arglists (quote ([b mv] [ctx b mv])), :doc "Given an expression and a monadic value,\n  if the expression is not logical true, return the monadic value.\n  Otherwise, return nil in a monadic context.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([b mv] [ctx b mv]), :arglists ([b mv] [ctx b mv]), :arglists-meta (nil nil)}}, :name cats.core/unless, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([b mv] [ctx b mv]), :arglists ([b mv] [ctx b mv]), :arglists-meta (nil nil)}, :method-params ([b mv] [ctx b mv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 210, :end-line 210, :max-fixed-arity 3, :fn-var true, :arglists ([b mv] [ctx b mv]), :doc "Given an expression and a monadic value,\n  if the expression is not logical true, return the monadic value.\n  Otherwise, return nil in a monadic context."}, traverse {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 845, :column 7, :end-line 845, :end-column 15, :arglists (quote ([f tv] [ctx f tv])), :doc "Map each element of a structure to an action, evaluate these\n  actions from left to right, and collect the results.\n\n      (defn inc-if-even\n        [n]\n        (if (even? n)\n          (maybe/just (inc n))\n          (maybe/nothing)))\n\n      (ctx/with-context maybe/context\n        (m/traverse inc-if-even [2 4]))\n      ;; => #<Just [3 4]>\n  ", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f tv] [ctx f tv]), :arglists ([f tv] [ctx f tv]), :arglists-meta (nil nil)}}, :name cats.core/traverse, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f tv] [ctx f tv]), :arglists ([f tv] [ctx f tv]), :arglists-meta (nil nil)}, :method-params ([f tv] [ctx f tv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 845, :end-line 845, :max-fixed-arity 3, :fn-var true, :arglists ([f tv] [ctx f tv]), :doc "Map each element of a structure to an action, evaluate these\n  actions from left to right, and collect the results.\n\n      (defn inc-if-even\n        [n]\n        (if (even? n)\n          (maybe/just (inc n))\n          (maybe/nothing)))\n\n      (ctx/with-context maybe/context\n        (m/traverse inc-if-even [2 4]))\n      ;; => #<Just [3 4]>\n  "}, forseq {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 685, :column 7, :end-line 685, :end-column 13, :arglists (quote ([vs mf])), :doc "Same as `mapseq` but with the arguments flipped.\n\n  Let's see a little example:\n\n      (m/forseq [2 3] maybe/just)\n      ;; => <Just [[2 3]]>\n\n  Yet an other example that fails:\n\n      (m/forseq [1 2]\n                (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing))))\n      ;; => <Nothing>\n  "}, :name cats.core/forseq, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 13, :method-params ([vs mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 685, :end-line 685, :max-fixed-arity 2, :fn-var true, :arglists (quote ([vs mf])), :doc "Same as `mapseq` but with the arguments flipped.\n\n  Let's see a little example:\n\n      (m/forseq [2 3] maybe/just)\n      ;; => <Just [[2 3]]>\n\n  Yet an other example that fails:\n\n      (m/forseq [1 2]\n                (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing))))\n      ;; => <Nothing>\n  "}, =<< {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 758, :column 7, :end-line 758, :end-column 10, :arglists (quote ([f mv])), :doc "Same as the two argument version of `>>=` but with the\n  arguments flipped."}, :name cats.core/=<<, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 10, :method-params ([f mv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 758, :end-line 758, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f mv])), :doc "Same as the two argument version of `>>=` but with the\n  arguments flipped."}, foldr {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 789, :column 7, :end-line 789, :end-column 12, :arglists (quote ([f z xs])), :doc "Perform a right-associative fold on the data structure."}, :name cats.core/foldr, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 12, :method-params ([f z xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 789, :end-line 789, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f z xs])), :doc "Perform a right-associative fold on the data structure."}, >=> {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 764, :column 7, :end-line 764, :end-column 10, :arglists (quote ([mf mg x])), :doc "Left-to-right composition of monads."}, :name cats.core/>=>, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 10, :method-params ([mf mg x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 764, :end-line 764, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mf mg x])), :doc "Left-to-right composition of monads."}, dependency-map {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 338, :column 8, :end-line 338, :end-column 22, :private true, :arglists (quote ([sym->ap]))}, :private true, :name cats.core/dependency-map, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 22, :method-params ([sym->ap]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 338, :end-line 338, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sym->ap]))}, <> {:name cats.core/<>, :file "out.prod.client/cats/core.cljc", :line 787, :column 1, :end-line 787, :end-column 8, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 787, :column 6, :end-line 787, :end-column 8}}, right-map {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 169, :column 7, :end-line 169, :end-column 16, :arglists (quote ([g] [g bv])), :doc "Map covariantly over the second argument.\n\n  Given a function `g` and a value wrapped in a bifunctor `bv`,\n  apply `g` to the second argument, if present, otherwise leave `bv` unchanged.\n\n      (right-map inc (either/right 1)\n      ;; => #<Right 2>\n\n      (right-map inc (either/left 1)\n      ;; => #<Left 1>", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([g] [g bv]), :arglists ([g] [g bv]), :arglists-meta (nil nil)}}, :name cats.core/right-map, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([g] [g bv]), :arglists ([g] [g bv]), :arglists-meta (nil nil)}, :method-params ([g] [g bv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 169, :end-line 169, :max-fixed-arity 2, :fn-var true, :arglists ([g] [g bv]), :doc "Map covariantly over the second argument.\n\n  Given a function `g` and a value wrapped in a bifunctor `bv`,\n  apply `g` to the second argument, if present, otherwise leave `bv` unchanged.\n\n      (right-map inc (either/right 1)\n      ;; => #<Right 2>\n\n      (right-map inc (either/left 1)\n      ;; => #<Left 1>"}, topo-sort {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 370, :column 8, :end-line 370, :end-column 17, :private true, :arglists (quote ([deps]))}, :private true, :name cats.core/topo-sort, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 17, :method-params ([deps]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 370, :end-line 370, :max-fixed-arity 1, :fn-var true, :arglists (quote ([deps]))}, filter {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 705, :column 7, :end-line 705, :end-column 13, :arglists (quote ([p mv])), :doc "Apply a predicate to a value in a `MonadZero` instance,\n  returning the identity element when the predicate does not hold.\n\n  Otherwise, return the instance unchanged.\n\n      (require '[cats.monad.maybe :as maybe])\n      (require '[cats.core :as m])\n\n      (m/filter (partial < 2) (maybe/just 3))\n      ;=> <Just [3]>\n\n      (m/filter (partial < 4) (maybe/just 3))\n      ;=> <Nothing>\n  "}, :name cats.core/filter, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 13, :method-params ([p mv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 705, :end-line 705, :max-fixed-arity 2, :fn-var true, :arglists (quote ([p mv])), :doc "Apply a predicate to a value in a `MonadZero` instance,\n  returning the identity element when the predicate does not hold.\n\n  Otherwise, return the instance unchanged.\n\n      (require '[cats.monad.maybe :as maybe])\n      (require '[cats.core :as m])\n\n      (m/filter (partial < 2) (maybe/just 3))\n      ;=> <Just [3]>\n\n      (m/filter (partial < 4) (maybe/just 3))\n      ;=> <Nothing>\n  "}, left-map {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 152, :column 7, :end-line 152, :end-column 15, :arglists (quote ([f] [f bv])), :doc "Map covariantly over the first argument.\n\n  Given a function `f` and a value wrapped in a bifunctor `bv`,\n  apply `f` to the first argument, if present, otherwise leave `bv` unchanged.\n\n      (left-map dec (either/right 1)\n      ;; => #<Right 1>\n\n      (left-map dec (either/left 1)\n      ;; => #<Left 0>", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f bv]), :arglists ([f] [f bv]), :arglists-meta (nil nil)}}, :name cats.core/left-map, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f bv]), :arglists ([f] [f bv]), :arglists-meta (nil nil)}, :method-params ([f] [f bv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 152, :end-line 152, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f bv]), :doc "Map covariantly over the first argument.\n\n  Given a function `f` and a value wrapped in a bifunctor `bv`,\n  apply `f` to the first argument, if present, otherwise leave `bv` unchanged.\n\n      (left-map dec (either/right 1)\n      ;; => #<Right 1>\n\n      (left-map dec (either/left 1)\n      ;; => #<Left 0>"}, dedupe-symbols* {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 298, :column 8, :end-line 298, :end-column 23, :private true, :arglists (quote ([sym->ap body]))}, :private true, :name cats.core/dedupe-symbols*, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 23, :method-params ([sym->ap body]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 298, :end-line 298, :max-fixed-arity 2, :fn-var true, :arglists (quote ([sym->ap body]))}, fmap {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 122, :column 7, :end-line 122, :end-column 11, :arglists (quote ([f] [f fv])), :doc "Apply a function `f` to the value wrapped in functor `fv`,\n  preserving the context type.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f fv]), :arglists ([f] [f fv]), :arglists-meta (nil nil)}}, :name cats.core/fmap, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f fv]), :arglists ([f] [f fv]), :arglists-meta (nil nil)}, :method-params ([f] [f fv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 122, :end-line 122, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f fv]), :doc "Apply a function `f` to the value wrapped in functor `fv`,\n  preserving the context type."}, mempty {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 44, :column 7, :end-line 44, :end-column 13, :arglists (quote ([] [ctx])), :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [ctx]), :arglists ([] [ctx]), :arglists-meta (nil nil)}}, :name cats.core/mempty, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [ctx]), :arglists ([] [ctx]), :arglists-meta (nil nil)}, :method-params ([] [ctx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 44, :end-line 44, :max-fixed-arity 1, :fn-var true, :arglists ([] [ctx])}, remove-deps {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 347, :column 8, :end-line 347, :end-column 19, :private true, :arglists (quote ([deps symset]))}, :private true, :name cats.core/remove-deps, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 19, :method-params ([deps symset]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 347, :end-line 347, :max-fixed-arity 2, :fn-var true, :arglists (quote ([deps symset]))}, extract {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 781, :column 7, :end-line 781, :end-column 14, :arglists (quote ([v])), :doc "Generic function to unwrap/extract\n  the inner value of a container."}, :name cats.core/extract, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 14, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 781, :end-line 781, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "Generic function to unwrap/extract\n  the inner value of a container."}, sequence {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 629, :column 7, :end-line 629, :end-column 15, :arglists (quote ([mvs])), :doc "Given a collection of monadic values, collect\n  their values in a seq returned in the monadic context.\n\n      (require '[cats.context :as ctx]\n               '[cats.monad.maybe :as maybe]\n               '[cats.core :as m])\n\n      (m/sequence [(maybe/just 2) (maybe/just 3)])\n      ;; => #<Just [[2, 3]]>\n\n      (m/sequence [(maybe/nothing) (maybe/just 3)])\n      ;; => #<Nothing>\n\n      (ctx/with-context maybe/context\n        (m/sequence []))\n      ;; => #<Just [()]>\n  "}, :name cats.core/sequence, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 15, :method-params ([mvs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 629, :end-line 629, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mvs])), :doc "Given a collection of monadic values, collect\n  their values in a seq returned in the monadic context.\n\n      (require '[cats.context :as ctx]\n               '[cats.monad.maybe :as maybe]\n               '[cats.core :as m])\n\n      (m/sequence [(maybe/just 2) (maybe/just 3)])\n      ;; => #<Just [[2, 3]]>\n\n      (m/sequence [(maybe/nothing) (maybe/just 3)])\n      ;; => #<Nothing>\n\n      (ctx/with-context maybe/context\n        (m/sequence []))\n      ;; => #<Just [()]>\n  "}, foldm {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 803, :column 7, :end-line 803, :end-column 12, :arglists (quote ([f z xs] [ctx f z xs])), :doc "Given an optional monadic context, a function that takes two non-monadic\n  arguments and returns a value inside the given monadic context, an initial\n  value, and a collection of values, perform a left-associative fold.\n\n      (require '[cats.context :as ctx]\n               '[cats.core :as m]\n               '[cats.monad.maybe :as maybe])\n\n      (defn m-div [x y]\n        (if (zero? y)\n          (maybe/nothing)\n          (maybe/just (/ x y))))\n\n      (m/foldm m-div 1 [1 2 3])\n      (m/foldm maybe/context m-div 1 [1 2 3])\n      ;; => #<Just 1/6>\n\n      (m/foldm maybe/context m-div 1 [1 0 3])\n      ;; => #<Nothing>\n\n      (foldm m-div 1 [])\n      ;; => Exception\n\n      (m/foldm maybe/context m-div 1 [])\n      (ctx/with-context maybe/context\n        (foldm m-div 1 []))\n      ;; => #<Just 1>\n  ", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([f z xs] [ctx f z xs]), :arglists ([f z xs] [ctx f z xs]), :arglists-meta (nil nil)}}, :name cats.core/foldm, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([f z xs] [ctx f z xs]), :arglists ([f z xs] [ctx f z xs]), :arglists-meta (nil nil)}, :method-params ([f z xs] [ctx f z xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 803, :end-line 803, :max-fixed-arity 4, :fn-var true, :arglists ([f z xs] [ctx f z xs]), :doc "Given an optional monadic context, a function that takes two non-monadic\n  arguments and returns a value inside the given monadic context, an initial\n  value, and a collection of values, perform a left-associative fold.\n\n      (require '[cats.context :as ctx]\n               '[cats.core :as m]\n               '[cats.monad.maybe :as maybe])\n\n      (defn m-div [x y]\n        (if (zero? y)\n          (maybe/nothing)\n          (maybe/just (/ x y))))\n\n      (m/foldm m-div 1 [1 2 3])\n      (m/foldm maybe/context m-div 1 [1 2 3])\n      ;; => #<Just 1/6>\n\n      (m/foldm maybe/context m-div 1 [1 0 3])\n      ;; => #<Nothing>\n\n      (foldm m-div 1 [])\n      ;; => Exception\n\n      (m/foldm maybe/context m-div 1 [])\n      (ctx/with-context maybe/context\n        (foldm m-div 1 []))\n      ;; => #<Just 1>\n  "}, bindings->batches {:protocol-inline nil, :meta {:file "/home/emh/github/rts/out.prod.client/cats/core.cljc", :line 375, :column 8, :end-line 375, :end-column 25, :private true, :arglists (quote ([bindings]))}, :private true, :name cats.core/bindings->batches, :variadic false, :file "out.prod.client/cats/core.cljc", :end-column 25, :method-params ([bindings]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 375, :end-line 375, :max-fixed-arity 1, :fn-var true, :arglists (quote ([bindings]))}}, :require-macros {cats.core cats.core, ctx cats.context, cats.context cats.context}, :cljs.analyzer/constants {:seen #{& :renames :else cats.core/fmap do :syms cats.core/fapply :aps :seen cats.core/join cljs.core/fn :arglists :body}, :order [:else :body :syms :aps :seen :renames cats.core/fmap cljs.core/fn cats.core/fapply do cats.core/join :arglists &]}, :doc "Category Theory abstractions for Clojure"}